#註記：在調用服務時，例如要從java webapp調用redis，可能會出現“redis: Temporary failure in name resolution”的錯誤。
#必須直接調用ip，請見下方 #Get Redis container IP
#  直接調用ip --> redis_ip=$(docker.......
#在SpringBoot application.properties中則是要寫 "spring.data.redis.host=${REDIS_IP}"

#抑或是要測試redis能不能ping到，請見下方 “檢查 Redis 準備OK” 中要打ip也是要取redis_ip=$(docker inspect --format
#後執行nc -z $redis_ip 6379

#在最後java webapp測試，請見下方 "測試應用程式是否連接正常"，設定curl -f http://spring-app:8080 則是出現“Could not resolve host: spring-app Error: Process completed with exit code 6.”的錯誤。
#調用spring_app_ip=$(docker inspect --format，並改為curl -f http://$SPRING_APP_IP:8080 才能執行

name: CI for Spring Boot and Redis

on:
  push:
    branches:
      - develop
  pull_request:
    branches:
      - develop

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    services:
      redis:
        image: redis:6.2
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 3

    steps:
      # 檢出程式碼
      - name: Checkout code
        uses: actions/checkout@v3

      # 設定 Java 環境
      - name: Set up JDK 23
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '23'

      # 建置 Maven 專案
      - name: Build with Maven
        run: mvn clean package -DskipTests

      - name: Verify target directory
        run: |
          ls -l target/

      # 建立 Docker 映像檔
      - name: Build Docker image
        run: |
          docker build -t my-spring-app .

      # 創建自定義 Docker 網絡
      - name: Create Docker network
        run: docker network create my-network

      # 啟動 Spring Boot 應用程式
      - name: Run Spring Boot application
        run: |
          docker run --network my-network -d --name spring-app my-spring-app

      # 檢查 Docker 容器狀態
      - name: Check Docker containers after Spring Boot startup
        run: docker ps  # 再次檢查是否有啟動 Spring Boot 容器

      # 安裝 redis-cli 並等待 Redis 就緒
      - name: Install redis-cli and wait for Redis to be ready
        run: |
          sudo apt-get update
          sudo apt-get install -y redis-tools
          until redis-cli -h 127.0.0.1 -p 6379 ping; do
            echo "Waiting for Redis to be ready..."
            sleep 5
          done

      # 檢查 Redis 準備OK
      - name: Wait for Redis to be ready
        run: |
          for i in {1..10}; do
            redis_container=$(docker ps -q --filter "ancestor=redis:6.2")
          
            if [ -z "$redis_container" ]; then
              echo "No Redis container found!"
              exit 1
            fi
          
            redis_ip=$(docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $redis_container)
          
            if nc -z $redis_ip 6379; then
              echo "Redis is ready!"
              exit 0
            fi
            echo "Waiting for Redis to be ready..."
            sleep 5
          done
          echo "Redis did not become ready in time!"
          exit 1

      #Get Redis container IP
      - name: Get Redis container IP
        run: |
          redis_ip=$(docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(docker ps -q --filter "ancestor=redis:6.2"))
          echo "REDIS_IP=$redis_ip" >> $GITHUB_ENV

      # 執行Maven測試
      - name: Run tests with Maven
        run: mvn test
        env:
          SPRING_REDIS_HOST: redis
          SPRING_REDIS_PORT: 6379

      # 測試應用程式是否連接正常(1/2)
      - name: Get Spring application container IP
        run: |
          spring_app_ip=$(docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' spring-app)
          echo "SPRING_APP_IP=$spring_app_ip" >> $GITHUB_ENV

      # 測試應用程式是否連接正常(2/2)
      - name: Test application
        run: |
          curl -f http://$SPRING_APP_IP:8080


      # 以下為AWS測試

      # 在 AWS 部署之前清理 Docker 容器
      - name: Clean up Docker containers
        run: |
          docker ps -a -q | xargs docker stop
          docker ps -a -q | xargs docker rm

      # AWS 驗證
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 打包專案為 ZIP 文件
      - name: Package application for Elastic Beanstalk
        run: |
          zip -r deployment-package.zip * .[^.]*

      # 部署到 Elastic Beanstalk
      - name: Deploy to Elastic Beanstalk
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip install awsebcli --upgrade --user
          
          export PATH=$PATH:$HOME/.local/bin
          
          eb init -p docker ${{ secrets.APPLICATION_NAME }} --region ${{ secrets.AWS_REGION }}
          
          eb use ${{ secrets.ELASTIC_BEANSTALK_ENV_NAME }}
          
          eb deploy --staged
          
